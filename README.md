# TG-Pre-Work

### While we do want our developers to work smarter, not harder, please refrain from plagiarizing.  It is completely fine to reword information you have gleaned from internet sources, however, please be prepared to redo the work should you submit a directly copied/pasted answer.  If you must copy/paste, cite your sources (this citation doesn't need to be fancy - just state directly where you found the information or provide a link).  Additionally, some of the questions below are tricky.  The answers were not necessarily covered in the reading we assigned.  They are not intended to be straightforward because we expect you to do some research to discover the answers to the best of your ability.  If you cannot find an answer, explain what you do know and what you are stuck on.  

## When we hit https://www.techtonic.com/ what happens? Don’t focus too much on architecture (Monolithic, SOA, Microservices, etc.). Try to focus more on how the web functions in general terms/steps.

Time to do some web browsing. I recently heard about this cool internship, shall we check out their webpage? Let’s open a browser and navigate to https://www.techtonic.com/ to find out more. Cool design, I love the arrow theme, looks like there is a ton of good information about the program here.
This seems like a simple, daily interaction that happens across the world, but what’s really going on behind the scenes? First, we typed in a URL. A URL is nice because it is human readable, but it isn’t what the browser is going to actually use. So, our browser will first check our cached IP addresses saved in our RAM. An IP address is a set of numbers that our computer can use to find another machine on a network; in this case a server. If we have visited this site recently, it will find the IP address in the cache. If not, the URL will be passed to our TCP/IP program which will prepare a packet of data to send a DNS request to a DNS resolver.
TCP/IP program is a 4 layer model, that means there are four parts to it designed to do and check for different things. The top layer (layer 4) is the TCP/UDP layer. This payer is in charge of first deciding if we need our request to be acknowledged or not. In this case, we do want our request acknowledge because we need a response. Therefore, we will use the TCP side. The TCP layer will take the packet of information from the browser (which was a DNS request with the URL to be resolved) and it will add two headers, a destination header and a source header. Basically, this means it will add information about where (and why) the packet is going out and it will add information about where the response should be returned. In this case, the outgoing port will be port 53, which is designated for DNS requests. The return/source port will be something above 1024.
Now, we need to send this data packet out to the world. Because the packet is a DNS request, we will send it to our DNS server. In this specific case, I am in we are in a residential house with a router. When this computer first connected to the router, the router provided a DNS IP address. Very likely, instead of supplying a real address (8.8.8.8 for example, which is one of Google’s main DNS servers) the router simply supplied its own IP address. That way, when our packet gets to the router it can see that we are sending our packet to port 53, it will therefore know that it is a DNS request, and it will be able to route the request to the correct IP address. 
But how does that packet get to our router? This is where the third layer of the TCP/IP program comes into play. That layer will find that DNS IP (in this case, just our router) and append it to our data packet. It will also append our own IP address (which was given to us by the router) so that the router knows where to send the response once it is ready. However, we can not just send a packet out to any IP address in the world, we have to be connected to it. Here is where our subnet mask (also provided by our router) comes into play. Basically, the subnet mask is a way for us to check if an IP address is on the same network as we are, and thus reachable. An IP address is made up of 4 discrete numbers and each is passed through the mask. This is done for both our IP address and for the one where we are trying to send the information (in this case, our DNS IP which is actually just our router.) The subnet mask is currently 255.255.255.0, as if often is. What this will do is return the same number for the first 3 pieces of the IP address and a 0 for the last piece. So, any IP address whose first three numbers match will be visible on this network. Our router has planned for that and it has given us an IP address within that range so that we can connect to the router via the provided subnet mask.
Now we know that the IP address where we are trying to send our packet of data about our DNS request is ready to go. However, we can not actually send information to IP addresses. Much like the URL is trying to lead us to the underlying IP address, and IP address simply serves to lead us to the underlying MAC address. MAC does not, in this case, have anything to do with the company Apple Inc. but rather stands for Media Access Control and every machine has one that is hardcoded to it. This is where level two of our TCP/IP program steps in. It will already have the MAC address for our router in its lookup table, so it will append that address to the data packet and now we are really ready to go.
We have a concrete MAC address, we know that that address is on our network, we have appended ports to tell the router what type of request we are making and where to send a response and we have included the base request, the URL we were searching for in the first place.
From here, we drop down to layer one, the physical layer. This is where we turn all of the characters of our data packet into binary and broadcast them out to our network. In this case, we are linked to our router via wireless, so the signal will be pulses of radio waves sent from our computer out to the house and they will be received by the router.
This same process will be repeated by each machine along the way, our router, the router at our ISP, etc. until the request hits the DNS server where a response will be crafted and returned via the same machines all the way down to our computer where we will receive the IP address for the techtonic.com website, 13.249.198.108. Next, we will reinitiate the process, but instead of asking for a DNS response, we will append the IP address we received and we will ask for the actual web page in return by using port 443 (because Techtonic is an https address).


## From start to finish, how does data reach you to be rendered in the browser and what code is rendered in the browser?

Now, let’s take a look at data coming in the opposite direction. Our request has finally made its way to the web server which is in charge of handling requests made to the IP address 13.249.198.108. That web server will take our request and send it to its backend. That is where the database lives, queries can be executed, and everything needed to assemble the webpage we asked for can be put together. That page is put together in HTML, and once everything is ready, the web server will send it back to our browser all ready to go.
Once the browser receives the data, it will render it to your screen. For the web page, we know that the layout is written with HTML, functionality is run through JavaScript, and the styling is read from the CSS. However, that server from question one can’t send actual code across the network to your browser. Rather, it sends the data in binary, in the form of bytes. In general, each byte represents a character. Let’s take a look at an example. When the Techtonic page is served to us, it is first rendering off of a single index HTML page (because the Techtonic site was written using Ember frontend). The first line of script in that page gives us the doctype, so the line is `<!DOCTYPE html>`. That first character, `<`, is represented in binary as 00111100. Our browser engine first works to take those bytes, like 00111100, and convert them back into characters to reconstruct the code behind the webpage. Now we have some files with text in them, great! Next, our browser engine needs to turn those pieces of text into usable code. The way it does this is by a process called tokenization. In tokenization, the browser engine looks at the file extension for each file that it received and uses its information about that language to interpret the different pieces of text. For example, in that first index.html file from Techtonic, the second piece of text is `<html lang="en">`. In tokenization, the browser will look at that file and understand that this is an html starting tag with a language attribute. If we had saved this same line in a .rb file, the browser would have no idea what that line meant because there is no corresponding token for `<html lang="en">` in Ruby.
Next, the browser will continue building. It will take related tokens and turn them into nodes, essentially objects, or sets of tokens that work together on the web page. From here, we are ready for the big step, assembling the DOM. But, what is the DOM? The DOM is an object which reads the HTML, identifies the different objects, and puts them in place in relationship to each other. In other words, it prepares the structure of the page. When it is reading an HTML object that has a tag to a CSS attribute, it knows that it needs some styling from the CSS. The CSS text is built up in much the same way that the DOM is, all the way from bytes of data, through to text, tokens, and eventually the CSSOM, the actual object level pieces of information about the styling. When the browser finds that the DOM needs CSS, it can go to its CSSOM to find the relevant information and then continue building up the DOM. With these two parts combined, we have our ‘render tree’. Essentially a page that is ready to go except that it knows nothing about the screen that it is to be rendered on. It is time for the layout step. This is where the browser calculates the size of the screen and the relationship that all of the different objects should have. Then, on it goes!
Optionally, the page may be (likely is) running JS code as well. The JS will be embedded as script tags and the construction of the DOM will be paused until those scripts are run. Often, especially in a modern JS framework like React or Ember, we will set those scripts to run asynchronously so that the user does not have to wait for the page to load while our scripts are run. Therefore, in the end, we will be rendering the code from the HTML, CSS, and JS files to our browser.


## What is the server-side code’s main function?

The main function of server-side code is to interact with permanent storage, usually a database. If an app is broken into front-end and back-end, this would be the back-end portion of the app. Server-side code stores information, retrieves information, and often controls routing (although this is changing with modern JS front-end frameworks that create a Single Page App but then provide routing to switch out components and display a different url to the user. This can be done in Ember through Ember routes or imported into React through React-Router.) Besides routing and processing database hits, the backend code is also generally responsible for user-validation through either a sessions process or by passing authorization tokens to the front-end. An app that relies heavily on server-side code will tend to be slower than one that processes directly in the users browser. This is one of the reasons that the modern JS frameworks have gained so much popularity.

## What is the client-side code’s main function?

Client-side code, code that runs in the user’s browser, is in charge of everything that the back-end/server-side is not doing for that application. That can be very little, or it can be quite a bit, depending on the architecture of the app. If we continue to use the Techtonic website as an example, Ember does as much processing as possible in the browser so that the user experience is as reactive as possible (which is where Ember’s biggest competitor, React.js, gets its name.) In this case, JavaScript functions and objects give the page the ability to change and adapt dynamically which user input without calling back to the server. We would see this in the form of buttons, toggles, tables, and even routing in Ember and React. The advantage to this type of setup is that the user does not need to wait for components to load. In fact, with the use of Ajax (asynchronously run JavaScript) pages can load even as the JS is still being run, giving an even more reactive experience.

## What is runtime?

Runtime is an interesting term because it can be used to mean a variety of different things given the context. In general, runtime is what happens when a program is executed. One of the most common places that a dev may run into the term is if they face a “Runtime error” message. In this case, runtime is used to distinguish between errors that would have been detected before a program was run, such as a syntax error or an error encountered during compiling.
The reason that the term is complex, however, is that it can also be used as a shortened form of other parts of a program that are involved with the program’s execution. The most common of these is the runtime-system, which can also be referred to as just runtime. The runtime system aides in the compiling of high-level languages, such as JS or Ruby, into lower level languages, such as C, before they are eventually turned into machine language. The runtime-system.
The program will also have a runtime-library, which provides specific functions that the runtime-system can use during execution of the program (i.e. runtime). These functions can help with things like memory allocation and are not generally ever touched or even seen by the dev working in the higher order language.
All three of these different terms can be referred to as ‘runtime’ and, in fact, they are all closely related. But the most general meaning of the word is the execution of a program or app.


## How many instances of the client-side assets (HTML, CSS, JS, Images, etc.) are created?

The server will send a copy of the client-side assets to each client that makes a request to there server. Therefore, if there are 20 people applying to Techtonic from their personal laptops at the same time, there will be an instance of the Ember code (Techtonic’s front-end/client-side framework) running on each person’s computer.

## How many instances of the server-side code are available at any given time?

The server-side code stays on the server and therefore does not need to be copied. It is available for each client when they sent a request to the server and that code can access the database and then send a response out to the individual computer.

## How many instances of the databases connected to the server application are created?

There is only one live copy of any given database at a time. That way, if one user makes a change, that would be reflected for other users. Let’s consider a site that has user authentication. If I get on my computer and signed up as fullstackdev@gmail.com and you got on the site a minute later and tried to sign up with the same email, the database would need to know that the email in question was already taken and therefore would have to be accessing the same database.
	However, from the developers point of view there may be other copies of the database which are not “live” for users. These would be copies that lived in the development and testing environments.
